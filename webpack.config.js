const HTMLWebpackPlugin = require('html-webpack-plugin');
const { WebpackPluginServe: Serve } = require('webpack-plugin-serve');
const MiniCSSExtractPlugin = require('mini-css-extract-plugin');
const CleanWebpackPlugin = require('clean-webpack-plugin');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const path = require('path');

/*
  *** Webpack does NOT rebundle when working with react!
  webpack-dev-server serves bundles from browser memory, not from file systems
  when it rebundles and serves, it serves from the memory files, not build/ folder
  
  paths in webpack must be absolute (use path.join/resolve)

  - webpack-dev-server only monitors changes to file trees in "entry"
  - 'watchContentBase' must be set to true for dev server to respond to changes in static files (contentBase)
  - static files are served from url pointed to by 'contentBase'
  - webpack-dev-server never uses the files generated by 'output', it only uses their names
  - all bundled code link hrefs must be relative to publicPath in config for development env
  - 'static' option designates non-webpack dir that will be passed into express.static(), it is not the same contentBase
  - entry: each key is the name of a chunk, value is the entry point
  - context: if manually designated, must set watchOptions.ignored, otherwise all files watched
  - liveReload: must hot=false and watchFiles=true for live reload to take effect
  - clean: !!! webpack-dev-server uses output.clean! and wipes out html files
  - webpack-dev-server uses output.publicPath (takes precedent) to serve virtual dir

  webpack-cli is just a wrapper for 'webpack' command to extend its options/ablities
  Note: use 'webpack serve' for webpack-cli 4.x in place of 'webpack-dev-server'

  For some CSS plugins, the plugins will automatically use publicPath to append css urls
  -css-loader does not work with root relative imports 'url('./filename')'

  webpack-plugin-serve
  -must add 'webpack-plugin-serve/client' to each entry point
  -must designate static directory
*/

module.exports = {
  mode: 'development',
  context: path.resolve(__dirname, 'Fourier/'), // always designate context to make it absolute
  entry: {
    index: [path.join(__dirname, 'client/index.js'), 'webpack-plugin-serve/client'], // wps has its own client entry in node_modules
    about: [path.join(__dirname, 'client/about.js'), 'webpack-plugin-serve/client']
  }, // what files should webpack transform?
  module: {
    rules: [ // what transformations should webpack perform? (called "loaders")
      {
        test: /\.js$/, // check which files to transform with this rule
        exclude: /node_modules/, // don't transform node_modules files
        use: 'babel-loader' // apply this loader, use the jsx parsing that comes with babel
      },
      {
        test: /\.(scss|css)$/,
        exclude: /node_modules/,
        use: [ 
          {
            loader: "style-loader"
          },
          //MiniCSSExtractPlugin.loader,
          { 
            loader: "css-loader",
            options: {
              sourceMap: true,
              // importLoaders: 2
              // url: true,
              // import: true
            }
          },
          {
            loader: "postcss-loader",
            options: {
              sourceMap: true,
              postcssOptions: {
                plugins: [ 'postcss-preset-env' ]
              }
            }
          },
          {
            loader: "sass-loader",
            options: {
              sourceMap: true
            }
          }
        ] // * order matters! (right-to-left!)
      } // compiles SASS -> to CSS -> compiles CSS -> style-loader inlines CSS into html
    ]
  },
  plugins: [ // need a new plugin instance to create new html file for each entry point
    // new CleanWebpackPlugin(), // for production only
    new HTMLWebpackPlugin({
      template: path.join(__dirname, 'client/template.html'), // uses original html as template
      filename: 'index.html', // new index.html build
      chunks: ['index'], // which entries to inject?
      inject: 'body', // where to insert <script src="index.html"></script> tag
      title: 'Fourier'
    }),
    new HTMLWebpackPlugin({
      template: path.join(__dirname, 'client/template.html'),
      filename: 'about.html',
      chunks: ['about'],
      inject: 'body',
      title: 'Fourier'
    }),
    new MiniCSSExtractPlugin(),
    // new CopyWebpackPlugin({
    //   patterns: [
    //     { from: 'scss', context: path.join(__dirname, 'client/') } // default 'output' dest
    //   ]
    // }),
    // new Serve({
    //   static: path.join(__dirname, 'client/'), // this particular static looks for build index files
    //   // liveReload: true,
    //   // hmr: true
    // })
  ],
  
  output: {
    filename: '[name].bundle.js', // output new build file, [name] uses chunk names
    path: path.join(__dirname, 'build/'), // build files are just bundles transformed by webpack loaders
    publicPath: '/', // redirects requests to this virtual directory in browser memory
    clean: true // -------- !!!!!!! ***** PROBLEM HERE ***** !!!!!!!!!!! -----------
  },
  optimization: {
    runtimeChunk: 'single' // must use this option when sharing modules in codesplitting
  },
  devtool: 'inline-source-map', // error-tracking so error not erased by bundle.js
  devServer: {
    // static: path.join(__dirname, 'client/'), // dir passed to express.static() in dev server, not same as contentBase
    static: {
      directory: path.join(__dirname, 'client/'),
      publicPath: '/'
    },
    client: {
      logging: 'verbose',
      overlay: true
    },
    hot: false,
    // liveReload: true
    // watchFiles: [ path.join(__dirname, 'client/') ]
    // watchOptions: {
    //   ignored: /node_modules/
    // }
    // staticWatch: true
  },
  watch: true
};